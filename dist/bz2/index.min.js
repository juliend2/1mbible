/*! bz2 (C) 2019-present SheetJS LLC */
"use strict";(function bz2(){const crc32Table=[0,79764919,159529838,222504665,319059676,398814059,445009330,507990021,638119352,583659535,797628118,726387553,890018660,835552979,1015980042,944750013,1276238704,1221641927,1167319070,1095957929,1595256236,1540665371,1452775106,1381403509,1780037320,1859660671,1671105958,1733955601,2031960084,2111593891,1889500026,1952343757,2552477408,2632100695,2443283854,2506133561,2334638140,2414271883,2191915858,2254759653,3190512472,3135915759,3081330742,3009969537,2905550212,2850959411,2762807018,2691435357,3560074640,3505614887,3719321342,3648080713,3342211916,3287746299,3467911202,3396681109,4063920168,4143685023,4223187782,4286162673,3779000052,3858754371,3904687514,3967668269,881225847,809987520,1023691545,969234094,662832811,591600412,771767749,717299826,311336399,374308984,453813921,533576470,25881363,88864420,134795389,214552010,2023205639,2086057648,1897238633,1976864222,1804852699,1867694188,1645340341,1724971778,1587496639,1516133128,1461550545,1406951526,1302016099,1230646740,1142491917,1087903418,2896545431,2825181984,2770861561,2716262478,3215044683,3143675388,3055782693,3001194130,2326604591,2389456536,2200899649,2280525302,2578013683,2640855108,2418763421,2498394922,3769900519,3832873040,3912640137,3992402750,4088425275,4151408268,4197601365,4277358050,3334271071,3263032808,3476998961,3422541446,3585640067,3514407732,3694837229,3640369242,1762451694,1842216281,1619975040,1682949687,2047383090,2127137669,1938468188,2001449195,1325665622,1271206113,1183200824,1111960463,1543535498,1489069629,1434599652,1363369299,622672798,568075817,748617968,677256519,907627842,853037301,1067152940,995781531,51762726,131386257,177728840,240578815,269590778,349224269,429104020,491947555,4046411278,4126034873,4172115296,4234965207,3794477266,3874110821,3953728444,4016571915,3609705398,3555108353,3735388376,3664026991,3290680682,3236090077,3449943556,3378572211,3174993278,3120533705,3032266256,2961025959,2923101090,2868635157,2813903052,2742672763,2604032198,2683796849,2461293480,2524268063,2284983834,2364738477,2175806836,2238787779,1569362073,1498123566,1409854455,1355396672,1317987909,1246755826,1192025387,1137557660,2072149281,2135122070,1912620623,1992383480,1753615357,1816598090,1627664531,1707420964,295390185,358241886,404320391,483945776,43990325,106832002,186451547,266083308,932423249,861060070,1041341759,986742920,613929101,542559546,756411363,701822548,3316196985,3244833742,3425377559,3370778784,3601682597,3530312978,3744426955,3689838204,3819031489,3881883254,3928223919,4007849240,4037393693,4100235434,4180117107,4259748804,2310601993,2373574846,2151335527,2231098320,2596047829,2659030626,2470359227,2550115596,2947551409,2876312838,2788305887,2733848168,3165939309,3094707162,3040238851,2985771188];const masks=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535,131071,262143,524287,1048575,2097151,4194303,8388607,16777215,33554431,67108863,134217727,268435455,536870911,1073741823,-2147483648];function createOrderedHuffmanTable(lengths){const z=[];for(let i=0;i<lengths.length;i+=1){z.push([i,lengths[i]])}z.push([lengths.length,-1]);const table=[];let start=z[0][0];let bits=z[0][1];for(let i=0;i<z.length;i+=1){const finish=z[i][0];const endbits=z[i][1];if(bits){for(let code=start;code<finish;code+=1){table.push({code:code,bits:bits,symbol:undefined})}}start=finish;bits=endbits;if(endbits===-1){break}}table.sort(((a,b)=>a.bits-b.bits||a.code-b.code));let tempBits=0;let symbol=-1;const fastAccess=[];let current;for(let i=0;i<table.length;i+=1){const t=table[i];symbol+=1;if(t.bits!==tempBits){symbol<<=t.bits-tempBits;tempBits=t.bits;current=fastAccess[tempBits]={}}t.symbol=symbol;current[symbol]=t}return{table:table,fastAccess:fastAccess}}function bwtReverse(src,primary){if(primary<0||primary>=src.length){throw RangeError("Out of bound")}const unsorted=src.slice();src.sort(((a,b)=>a-b));const start={};for(let i=src.length-1;i>=0;i-=1){start[src[i]]=i}const links=[];for(let i=0;i<src.length;i+=1){links.push(start[unsorted[i]]++)}let i;const first=src[i=primary];const ret=[];for(let j=1;j<src.length;j+=1){const x=src[i=links[i]];if(x===undefined){ret.push(255)}else{ret.push(x)}}ret.push(first);ret.reverse();return ret}function decompress(bytes,checkCRC=false){let index=0;let bitfield=0;let bits=0;const read=n=>{if(n>=32){const nd=n>>1;return read(nd)*(1<<nd)+read(n-nd)}while(bits<n){bitfield=(bitfield<<8)+bytes[index];index+=1;bits+=8}const m=masks[n];const r=bitfield>>bits-n&m;bits-=n;bitfield&=~(m<<bits);return r};const magic=read(16);if(magic!==16986){throw new Error("Invalid magic")}const method=read(8);if(method!==104){throw new Error("Invalid method")}let blocksize=read(8);if(blocksize>=49&&blocksize<=57){blocksize-=48}else{throw new Error("Invalid blocksize")}let out=new Uint8Array(bytes.length*1.5);let outIndex=0;let newCRC=-1;while(true){const blocktype=read(48);const crc=read(32)|0;if(blocktype===54156738319193){if(read(1)){throw new Error("do not support randomised")}const pointer=read(24);const used=[];const usedGroups=read(16);for(let i=1<<15;i>0;i>>=1){if(!(usedGroups&i)){for(let j=0;j<16;j+=1){used.push(false)}continue}const usedChars=read(16);for(let j=1<<15;j>0;j>>=1){used.push(!!(usedChars&j))}}const groups=read(3);if(groups<2||groups>6){throw new Error("Invalid number of huffman groups")}const selectorsUsed=read(15);const selectors=[];const mtf=Array.from({length:groups},((_,i)=>i));for(let i=0;i<selectorsUsed;i+=1){let c=0;while(read(1)){c+=1;if(c>=groups){throw new Error("MTF table out of range")}}const v=mtf[c];for(let j=c;j>0;mtf[j]=mtf[--j]){}selectors.push(v);mtf[0]=v}const symbolsInUse=used.reduce(((a,b)=>a+b),0)+2;const tables=[];for(let i=0;i<groups;i+=1){let length=read(5);const lengths=[];for(let j=0;j<symbolsInUse;j+=1){if(length<0||length>20){throw new Error("Huffman group length outside range")}while(read(1)){length-=read(1)*2-1}lengths.push(length)}tables.push(createOrderedHuffmanTable(lengths))}const favourites=[];for(let i=0;i<used.length-1;i+=1){if(used[i]){favourites.push(i)}}let decoded=0;let selectorPointer=0;let t;let r;let repeat=0;let repeatPower=0;const buffer=[];while(true){decoded-=1;if(decoded<=0){decoded=50;if(selectorPointer<=selectors.length){t=tables[selectors[selectorPointer]];selectorPointer+=1}}for(const b in t.fastAccess){if(!Object.prototype.hasOwnProperty.call(t.fastAccess,b)){continue}if(bits<b){bitfield=(bitfield<<8)+bytes[index];index+=1;bits+=8}r=t.fastAccess[b][bitfield>>bits-b];if(r){bitfield&=masks[bits-=b];r=r.code;break}}if(r>=0&&r<=1){if(repeat===0){repeatPower=1}repeat+=repeatPower<<r;repeatPower<<=1;continue}else{const v=favourites[0];for(;repeat>0;repeat-=1){buffer.push(v)}}if(r===symbolsInUse-1){break}else{const v=favourites[r-1];for(let j=r-1;j>0;favourites[j]=favourites[--j]){}favourites[0]=v;buffer.push(v)}}const nt=bwtReverse(buffer,pointer);let i=0;while(i<nt.length){const c=nt[i];let count=1;if(i<nt.length-4&&nt[i+1]===c&&nt[i+2]===c&&nt[i+3]===c){count=nt[i+4]+4;i+=5}else{i+=1}if(outIndex+count>=out.length){const old=out;out=new Uint8Array(old.length*2);out.set(old)}for(let j=0;j<count;j+=1){if(checkCRC){newCRC=newCRC<<8^crc32Table[(newCRC>>24^c)&255]}out[outIndex]=c;outIndex+=1}}if(checkCRC){const calculatedCRC=newCRC^-1;if(calculatedCRC!==crc){throw new Error(`CRC mismatch: ${calculatedCRC} !== ${crc}`)}newCRC=-1}}else if(blocktype===25779555029136){read(bits&7);break}else{throw new Error("Invalid bz2 blocktype")}}return out.subarray(0,outIndex)}const exports={decompress:decompress};if(typeof window!=="undefined"){window.bz2=exports}else{module.exports=exports}})();